package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"fmt"
	"sventory/internal/database"
	"sventory/internal/graph/generated"
	"sventory/internal/graph/model"

	"github.com/google/uuid"
)

// CreateItem is the resolver for the createItem field.
func (r *mutationResolver) CreateItem(ctx context.Context, input model.CreateItemInput) (*model.Item, error) {
	fmt.Print("CreateItem resolver")

	categoryID, err := uuid.Parse(input.CategoryID)
	if err != nil {
		return nil, err
	}

	item := &model.Item{
		CategoryID:    categoryID,
		SKU:           input.Sku,
		Name:          input.Name,
		Description:   getStringValue(input.Description),
		Quantity:      input.Quantity,
		UnitOfMeasure: input.UnitOfMeasure,
		MinimumStock:  getFloatValue(input.MinimumStock),
		MaximumStock:  getFloatValue(input.MaximumStock),
		ReorderPoint:  getFloatValue(input.ReorderPoint),
		CostPrice:     getIntValue(input.CostPrice),
		SellingPrice:  getIntValue(input.SellingPrice),
		MSRP:          getIntValue(input.Msrp),
		Barcode:       getStringValue(input.Barcode),
		Weight:        getFloatValue(input.Weight),
		Dimensions:    getStringValue(input.Dimensions),
	}

	if err := database.DB.Create(&item).Error; err != nil {
		return nil, err
	}

	// Add the item image if provided
	if input.Image != nil {
		uploadImageInput := model.UploadItemImageInput{
			ItemID: item.ID.String(),
			Image:  *input.Image,
		}
		_, err := r.UploadItemImage(ctx, uploadImageInput)
		if err != nil {
			return nil, err
		}
	}

	return item, nil
}

// UpdateItem is the resolver for the updateItem field.
func (r *mutationResolver) UpdateItem(ctx context.Context, id string, input model.UpdateItemInput) (*model.Item, error) {
	var item model.Item
	if err := database.DB.First(&item, "id = ?", id).Error; err != nil {
		return nil, err
	}

	if input.CategoryID != nil {
		categoryId, err := uuid.Parse(*input.CategoryID)
		if err != nil {
			return nil, err
		}
		item.CategoryID = categoryId
	}

	if input.Sku != nil {
		item.SKU = *input.Sku
	}

	if input.Name != nil {
		item.Name = *input.Name
	}

	if input.Description != nil {
		item.Description = *input.Description
	}

	if input.Quantity != nil {
		item.Quantity = *input.Quantity
	}

	if input.UnitOfMeasure != nil {
		item.UnitOfMeasure = *input.UnitOfMeasure
	}

	if input.MinimumStock != nil {
		item.MinimumStock = *input.MinimumStock
	}

	if input.MaximumStock != nil {
		item.MaximumStock = *input.MaximumStock
	}

	if input.ReorderPoint != nil {
		item.ReorderPoint = *input.ReorderPoint
	}

	if input.CostPrice != nil {
		item.CostPrice = *input.CostPrice
	}

	if input.SellingPrice != nil {
		item.SellingPrice = *input.SellingPrice
	}

	if input.Msrp != nil {
		item.MSRP = *input.Msrp
	}

	if input.Barcode != nil {
		item.Barcode = *input.Barcode
	}

	if input.Weight != nil {
		item.Weight = *input.Weight
	}

	if input.Dimensions != nil {
		item.Dimensions = *input.Dimensions
	}

	if err := database.DB.Save(&item).Error; err != nil {
		return nil, err
	}

	// Update the item image if provided
	if input.Image != nil {
		uploadImageInput := model.UploadItemImageInput{
			ItemID: item.ID.String(),
			Image:  *input.Image,
		}
		_, err := r.UploadItemImage(ctx, uploadImageInput)
		if err != nil {
			return nil, err
		}
	}

	return &item, nil
}

// DeleteItem is the resolver for the deleteItem field.
func (r *mutationResolver) DeleteItem(ctx context.Context, id string) (bool, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}
	if err := database.DB.Delete(&model.Item{}, "id = ?", entityID).Error; err != nil {
		return false, err
	}

	return true, nil
}

// Items is the resolver for the items field.
func (r *queryResolver) Items(ctx context.Context, options *model.QueryOptions) ([]*model.Item, error) {
	var items []*model.Item

	query := database.DB.Model(&model.Item{})

	if options != nil {
		var err error
		query, err = model.ApplyQueryOptions(query, *options, &model.Item{})
		if err != nil {
			return nil, err
		}
	}

	if err := query.Find(&items).Error; err != nil {
		return nil, err
	}

	return items, nil
}

// Item is the resolver for the item field.
func (r *queryResolver) Item(ctx context.Context, id string) (*model.Item, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	var item model.Item
	if err := database.DB.First(&item, "id = ?", entityID).Error; err != nil {
		return nil, err
	}

	return &item, nil
}

// ID is the resolver for the id field.
func (r *itemResolver) ID(ctx context.Context, obj *model.Item) (string, error) {
	return obj.ID.String(), nil
}

// Category is the resolver for the category field.
func (r *itemResolver) Category(ctx context.Context, obj *model.Item) (*model.ItemCategory, error) {
	var category model.ItemCategory

	if err := database.DB.First(&category, "id = ?", obj.CategoryID).Error; err != nil {
		return nil, err
	}

	return &category, nil
}

// Item returns generated.ItemResolver implementation.
func (r *Resolver) Item() generated.ItemResolver { return &itemResolver{r} }

type itemResolver struct{ *Resolver }
