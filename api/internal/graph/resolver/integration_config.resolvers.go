package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"sventory/internal/database"
	"sventory/internal/graph/generated"
	"sventory/internal/graph/model"

	"github.com/google/uuid"
)

// CreateIntegrationConfig is the resolver for the createIntegrationConfig field.
func (r *mutationResolver) CreateIntegrationConfig(ctx context.Context, input model.CreateIntegrationConfigInput) (*model.IntegrationConfig, error) {
	organizationID, err := uuid.Parse(input.OrganizationID)
	if err != nil {
		return nil, err
	}

	integrationConfig := &model.IntegrationConfig{
		OrganizationID: organizationID,
		Name:           input.Name,
		Type:           input.Type,
		APIKey:         input.APIKey,
		APISecret:      input.APISecret,
	}
	if err := database.DB.Create(integrationConfig).Error; err != nil {
		return nil, err
	}
	return integrationConfig, nil
}

// UpdateIntegrationConfig is the resolver for the updateIntegrationConfig field.
func (r *mutationResolver) UpdateIntegrationConfig(ctx context.Context, id string, input model.UpdateIntegrationConfigInput) (*model.IntegrationConfig, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	var integrationConfig model.IntegrationConfig
	if err := database.DB.First(&integrationConfig, "id = ?", entityID).Error; err != nil {
		return nil, err
	}

	if input.Name != nil {
		integrationConfig.Name = *input.Name
	}

	if input.Type != nil {
		integrationConfig.Type = *input.Type
	}

	if input.APIKey != nil {
		integrationConfig.APIKey = *input.APIKey
	}

	if input.APISecret != nil {
		integrationConfig.APISecret = *input.APISecret
	}

	if err := database.DB.Save(&integrationConfig).Error; err != nil {
		return nil, err
	}

	return &integrationConfig, nil
}

// DeleteIntegrationConfig is the resolver for the deleteIntegrationConfig field.
func (r *mutationResolver) DeleteIntegrationConfig(ctx context.Context, id string) (bool, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}

	if err := database.DB.Delete(&model.IntegrationConfig{}, "id = ?", entityID).Error; err != nil {
		return false, err
	}

	return true, nil
}

// IntegrationConfigs is the resolver for the integrationConfigs field.
func (r *queryResolver) IntegrationConfigs(ctx context.Context, options *model.QueryOptions) ([]*model.IntegrationConfig, error) {
	var integrationConfigs []*model.IntegrationConfig
	query := database.DB.Model(&model.IntegrationConfig{})

	if options != nil {
		var err error
		query, err = model.ApplyQueryOptions(query, *options, &model.IntegrationConfig{})
		if err != nil {
			return nil, err
		}
	}

	if err := query.Find(&integrationConfigs).Error; err != nil {
		return nil, err
	}

	return integrationConfigs, nil
}

// IntegrationConfig is the resolver for the integrationConfig field.
func (r *queryResolver) IntegrationConfig(ctx context.Context, id string) (*model.IntegrationConfig, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	var integrationConfig model.IntegrationConfig
	if err := database.DB.First(&integrationConfig, "id = ?", entityID).Error; err != nil {
		return nil, err
	}

	return &integrationConfig, nil
}

// ID is the resolver for the id field.
func (r *integrationConfigResolver) ID(ctx context.Context, obj *model.IntegrationConfig) (string, error) {
	return obj.ID.String(), nil
}

// Organization is the resolver for the organization field.
func (r *integrationConfigResolver) Organization(ctx context.Context, obj *model.IntegrationConfig) (*model.Organization, error) {
	var organization model.Organization
	if err := database.DB.First(&organization, "id = ?", obj.OrganizationID).Error; err != nil {
		return nil, err
	}

	return &organization, nil
}

// IntegrationConfig returns generated.IntegrationConfigResolver implementation.
func (r *Resolver) IntegrationConfig() generated.IntegrationConfigResolver {
	return &integrationConfigResolver{r}
}

type integrationConfigResolver struct{ *Resolver }
