package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"

	"sventory/internal/database"
	"sventory/internal/graph/generated"
	"sventory/internal/graph/model"

	"github.com/google/uuid"
)

// CreateCustomerAccount is the resolver for the createCustomerAccount field.
func (r *mutationResolver) CreateCustomerAccount(ctx context.Context, input model.CreateCustomerAccountInput) (*model.CustomerAccount, error) {
	password, err := hashPassword(input.Password)
	if err != nil {
		return nil, err
	}

	organizationID, err := uuid.Parse(input.OrganizationID)
	if err != nil {
		return nil, err
	}

	customerAccount := &model.CustomerAccount{
		OrganizationID: organizationID,
		Name:           input.Name,
		Email:          input.Email,
		Password:       password,
		Phone:          getStringValue(input.Phone),
		AddressLine1:   getStringValue(input.AddressLine1),
		AddressLine2:   getStringValue(input.AddressLine2),
		City:           getStringValue(input.City),
		State:          getStringValue(input.State),
		PostalCode:     getStringValue(input.PostalCode),
		Country:        getStringValue(input.Country),
		TaxID:          getStringValue(input.TaxID),
		Notes:          getStringValue(input.Notes),
		Status:         getStringValue(input.Status),
	}

	if err := database.DB.Create(customerAccount).Error; err != nil {
		return nil, err
	}

	return customerAccount, nil
}

// UpdateCustomerAccount is the resolver for the updateCustomerAccount field.
func (r *mutationResolver) UpdateCustomerAccount(ctx context.Context, id string, input model.UpdateCustomerAccountInput) (*model.CustomerAccount, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	var customerAccount model.CustomerAccount
	if err := database.DB.First(&customerAccount, "id = ?", entityID).Error; err != nil {
		return nil, err
	}

	if input.Name != nil {
		customerAccount.Name = *input.Name
	}

	if input.Email != nil {
		customerAccount.Email = *input.Email
	}

	if input.Password != nil {
		password, err := hashPassword(getStringValue(input.Password))
		if err != nil {
			return nil, err
		}
		customerAccount.Password = password
	}

	if input.Phone != nil {
		customerAccount.Phone = *input.Phone
	}

	if input.AddressLine1 != nil {
		customerAccount.AddressLine1 = *input.AddressLine1
	}

	if input.AddressLine2 != nil {
		customerAccount.AddressLine2 = *input.AddressLine2
	}

	if input.City != nil {
		customerAccount.City = *input.City
	}

	if input.State != nil {
		customerAccount.State = *input.State
	}

	if input.PostalCode != nil {
		customerAccount.PostalCode = *input.PostalCode
	}

	if input.Country != nil {
		customerAccount.Country = *input.Country
	}

	if input.TaxID != nil {
		customerAccount.TaxID = *input.TaxID
	}

	if input.Notes != nil {
		customerAccount.Notes = *input.Notes
	}

	if input.Status != nil {
		customerAccount.Status = *input.Status
	}

	if err := database.DB.Save(&customerAccount).Error; err != nil {
		return nil, err
	}

	return &customerAccount, nil
}

// DeleteCustomerAccount is the resolver for the deleteCustomerAccount field.
func (r *mutationResolver) DeleteCustomerAccount(ctx context.Context, id string) (bool, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}

	if err := database.DB.Delete(&model.CustomerAccount{}, "id = ?", entityID).Error; err != nil {
		return false, err
	}

	return true, nil
}

// CustomerAccounts is the resolver for the customerAccounts field.
func (r *queryResolver) CustomerAccounts(ctx context.Context, options *model.QueryOptions) ([]*model.CustomerAccount, error) {
	var customerAccounts []*model.CustomerAccount
	query := database.DB.Model(&model.CustomerAccount{})

	if options != nil {
		var err error
		query, err = model.ApplyQueryOptions(query, *options, &model.CustomerAccount{})
		if err != nil {
			return nil, err
		}
	}

	if err := query.Find(&customerAccounts).Error; err != nil {
		return nil, err
	}

	return customerAccounts, nil
}

// CustomerAccount is the resolver for the customerAccount field.
func (r *queryResolver) CustomerAccount(ctx context.Context, id string) (*model.CustomerAccount, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	var customerAccount model.CustomerAccount
	if err := database.DB.First(&customerAccount, "id = ?", entityID).Error; err != nil {
		return nil, err
	}

	return &customerAccount, nil
}

// ID is the resolver for the id field.
func (r *customerAccountResolver) ID(ctx context.Context, obj *model.CustomerAccount) (string, error) {
	return obj.ID.String(), nil
}

// Organization is the resolver for the organization field.
func (r *customerAccountResolver) Organization(ctx context.Context, obj *model.CustomerAccount) (*model.Organization, error) {
	var organization model.Organization
	if err := database.DB.First(&organization, "id = ?", obj.OrganizationID).Error; err != nil {
		return nil, err
	}
	return &organization, nil
}

// CustomerAccount returns generated.CustomerAccountResolver implementation.
func (r *Resolver) CustomerAccount() generated.CustomerAccountResolver {
	return &customerAccountResolver{r}
}

type customerAccountResolver struct{ *Resolver }
