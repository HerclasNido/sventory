package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"errors"
	"fmt"
	"sventory/internal/database"
	"sventory/internal/graph/generated"
	"sventory/internal/graph/model"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// CreateLocation is the resolver for the createLocation field.
func (r *mutationResolver) CreateLocation(ctx context.Context, input model.CreateLocationInput) (*model.Location, error) {
	placeID, err := uuid.Parse(input.PlaceID)
	if err != nil {
		return nil, fmt.Errorf("parsing location ID: %w", err)
	}

	location := model.Location{
		PlaceID:     placeID,
		Name:        input.Name,
		Type:        input.Type,
		Description: getStringValue(input.Description),
	}

	if input.ParentLocationID != nil {
		if *input.ParentLocationID == "" {
			location.ParentLocationID = uuid.Nil
		} else {
			parentLocationID, err := uuid.Parse(getStringValue(input.ParentLocationID))
			if err != nil {
				return nil, err
			}
			location.ParentLocationID = parentLocationID
		}
	}

	if err := database.DB.Create(&location).Error; err != nil {
		return nil, fmt.Errorf("creating location: %w", err)
	}

	return &location, nil
}

// UpdateLocation is the resolver for the updateLocation field.
func (r *mutationResolver) UpdateLocation(ctx context.Context, id string, input model.UpdateLocationInput) (*model.Location, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	var location model.Location
	if err := database.DB.First(&location, "id = ?", entityID).Error; err != nil {
		return nil, fmt.Errorf("finding location: %w", err)
	}

	if input.PlaceID != nil {
		placeID, err := uuid.Parse(getStringValue(input.PlaceID))
		if err != nil {
			return nil, err
		}
		location.PlaceID = placeID
	}

	if input.ParentLocationID != nil {
		if *input.ParentLocationID == "" {
			location.ParentLocationID = uuid.Nil
		} else {
			parentLocationID, err := uuid.Parse(getStringValue(input.ParentLocationID))
			if err != nil {
				return nil, err
			}

			if parentLocationID == entityID {
				return nil, errors.New("location cannot be its own parent")
			}

			location.ParentLocationID = parentLocationID
		}
	}

	if input.Name != nil {
		location.Name = *input.Name
	}

	if input.Type != nil {
		location.Type = *input.Type
	}

	if input.Description != nil {
		location.Description = *input.Description
	}

	if err := database.DB.Save(&location).Error; err != nil {
		return nil, fmt.Errorf("updating location: %w", err)
	}

	return &location, nil
}

// DeleteLocation is the resolver for the deleteLocation field.
func (r *mutationResolver) DeleteLocation(ctx context.Context, id string) (bool, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return false, err
	}

	// Prevent deletion of location with dependent items
	var itemCount int64
	if err := database.DB.Model(&model.Item{}).Where("location_id = ?", entityID).Count(&itemCount).Error; err != nil {
		return false, fmt.Errorf("counting dependent items: %w", err)
	}
	if itemCount > 0 {
		return false, errors.New("cannot delete location with dependent items")
	}

	// Prevent deletion of location with dependent child locations
	var childrenCount int64
	if err := database.DB.Model(&model.Location{}).Where("parent_location_id = ?", entityID).Count(&childrenCount).Error; err != nil {
		return false, fmt.Errorf("counting dependent locations: %w", err)
	}
	if childrenCount > 0 {
		return false, errors.New("cannot delete location with dependent child locations")
	}

	if err := database.DB.Delete(&model.Location{}, "id = ?", entityID).Error; err != nil {
		return false, fmt.Errorf("deleting location: %w", err)
	}

	return true, nil
}

// Locations is the resolver for the locations field.
func (r *queryResolver) Locations(ctx context.Context, options *model.QueryOptions) ([]*model.Location, error) {
	var locations []*model.Location

	query := database.DB.Model(&model.Location{})

	if options != nil {
		var err error
		query, err = model.ApplyQueryOptions(query, *options, &model.Location{})
		if err != nil {
			return nil, err
		}
	}

	if err := query.Find(&locations).Error; err != nil {
		return nil, fmt.Errorf("finding locations: %w", err)
	}

	return locations, nil
}

// Location is the resolver for the location field.
func (r *queryResolver) Location(ctx context.Context, id string) (*model.Location, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	var location model.Location
	if err := database.DB.First(&location, "id = ?", entityID).Error; err != nil {
		return nil, fmt.Errorf("finding location: %w", err)
	}

	return &location, nil
}

// ID is the resolver for the id field.
func (r *locationResolver) ID(ctx context.Context, obj *model.Location) (string, error) {
	return obj.ID.String(), nil
}

// Place is the resolver for the place field.
func (r *locationResolver) Place(ctx context.Context, obj *model.Location) (*model.Place, error) {
	var place model.Place
	if err := database.DB.First(&place, "id = ?", obj.PlaceID).Error; err != nil {
		return nil, fmt.Errorf("finding location's place: %w", err)
	}

	return &place, nil
}

// ParentLocation is the resolver for the parentLocation field.
func (r *locationResolver) ParentLocation(ctx context.Context, obj *model.Location) (*model.Location, error) {
	if obj.ParentLocationID == uuid.Nil {
		return nil, nil
	}

	var parentLocation model.Location
	if err := database.DB.First(&parentLocation, "id = ?", obj.ParentLocationID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, fmt.Errorf("finding parent location: %w", err)
	}

	return &parentLocation, nil
}

// ChildLocations is the resolver for the childLocations field.
func (r *locationResolver) ChildLocations(ctx context.Context, obj *model.Location) ([]*model.Location, error) {
	var childLocations []*model.Location

	if err := database.DB.Model(&obj).Association("ChildLocations").Find(&childLocations); err != nil {
		return nil, fmt.Errorf("finding child locations: %w", err)
	}

	return childLocations, nil
}

// Location returns generated.LocationResolver implementation.
func (r *Resolver) Location() generated.LocationResolver { return &locationResolver{r} }

type locationResolver struct{ *Resolver }
