package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.63

import (
	"context"
	"errors"
	"fmt"
	"sventory/internal/database"
	"sventory/internal/graph/generated"
	"sventory/internal/graph/model"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

// CreateItemCategory is the resolver for the createItemCategory field.
func (r *mutationResolver) CreateItemCategory(ctx context.Context, input model.CreateItemCategoryInput) (*model.ItemCategory, error) {
	organizationID, err := uuid.Parse(input.OrganizationID)
	if err != nil {
		return nil, err
	}

	itemCategory := &model.ItemCategory{
		OrganizationID: organizationID,
		Name:           input.Name,
		Description:    getStringValue(input.Description),
	}

	if input.ParentCategoryID != nil {
		if *input.ParentCategoryID == "" {
			itemCategory.ParentCategoryID = uuid.Nil
		} else {
			parentLocationID, err := uuid.Parse(getStringValue(input.ParentCategoryID))
			if err != nil {
				return nil, err
			}
			itemCategory.ParentCategoryID = parentLocationID
		}
	}

	if err := database.DB.Create(&itemCategory).Error; err != nil {
		return nil, err
	}

	return itemCategory, nil
}

// UpdateItemCategory is the resolver for the updateItemCategory field.
func (r *mutationResolver) UpdateItemCategory(ctx context.Context, id string, input model.UpdateItemCategoryInput) (*model.ItemCategory, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}

	var itemCategory model.ItemCategory
	if err := database.DB.First(&itemCategory, "id = ?", entityID).Error; err != nil {
		return nil, fmt.Errorf("finding item category: %w", err)
	}

	if input.Name != nil {
		itemCategory.Name = *input.Name
	}

	if input.Description != nil {
		itemCategory.Description = *input.Description
	}

	if input.ParentCategoryID != nil {
		if *input.ParentCategoryID == "" {
			itemCategory.ParentCategoryID = uuid.Nil
		} else {
			parentCategoryID, err := uuid.Parse(getStringValue(input.ParentCategoryID))
			if err != nil {
				return nil, err
			}

			if parentCategoryID == entityID {
				return nil, errors.New("category cannot be its own parent")
			}

			itemCategory.ParentCategoryID = parentCategoryID
		}
	}

	if err := database.DB.Save(&itemCategory).Error; err != nil {
		return nil, err
	}

	return &itemCategory, nil
}

// DeleteItemCategory is the resolver for the deleteItemCategory field.
func (r *mutationResolver) DeleteItemCategory(ctx context.Context, id string) (bool, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return false, model.NewError(model.ValidationError, err.Error())
	}

	// Prevent deletion of item category if it has items
	var itemCount int64
	if err := database.DB.Model(&model.Item{}).Where("category_id = ?", entityID).Count(&itemCount).Error; err != nil {
		return false, model.NewError(model.InternalError, err.Error())
	}
	if itemCount > 0 {
		return false, model.NewError(model.ValidationError, "cannot delete category with items")
	}

	// Prevent deletion of item category if it has child categories
	var childrenCount int64
	if err := database.DB.Model(&model.ItemCategory{}).Where("parent_category_id = ?", entityID).Count(&childrenCount).Error; err != nil {
		return false, model.NewError(model.InternalError, err.Error())
	}
	if childrenCount > 0 {
		customErr := model.NewError(model.HasChildrenError, "cannot delete category with child categories")
		fmt.Printf("Returning custom error: %+v of type %T", customErr, customErr) // Debug log
		return false, customErr
	}

	if err := database.DB.Delete(&model.ItemCategory{}, "id = ?", entityID).Error; err != nil {
		return false, model.NewError(model.InternalError, err.Error())
	}

	return true, nil
}

// ParentCategory is the resolver for the parentCategory field.
func (r *itemCategoryResolver) ParentCategory(ctx context.Context, obj *model.ItemCategory) (*model.ItemCategory, error) {
	if obj.ParentCategoryID == uuid.Nil {
		return nil, nil
	}

	var parentCategory model.ItemCategory
	if err := database.DB.First(&parentCategory, "id = ?", obj.ParentCategoryID).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, fmt.Errorf("finding parent category: %w", err)
	}

	return &parentCategory, nil
}

// ChildCategories is the resolver for the childCategories field.
func (r *itemCategoryResolver) ChildCategories(ctx context.Context, obj *model.ItemCategory) ([]*model.ItemCategory, error) {
	var childCategories []*model.ItemCategory
	if err := database.DB.Where("parent_category_id = ?", obj.ID).Find(&childCategories).Error; err != nil {
		return nil, err
	}
	return childCategories, nil
}

// Items is the resolver for the items field.
func (r *itemCategoryResolver) Items(ctx context.Context, obj *model.ItemCategory) ([]*model.Item, error) {
	var items []*model.Item
	if err := database.DB.Where("category_id = ?", obj.ID).Find(&items).Error; err != nil {
		return nil, err
	}
	return items, nil
}

// ItemCategories is the resolver for the itemCategories field.
func (r *queryResolver) ItemCategories(ctx context.Context, options *model.QueryOptions) ([]*model.ItemCategory, error) {
	var itemCategories []*model.ItemCategory
	query := database.DB.Model(&model.ItemCategory{})
	if options != nil {
		var err error
		query, err = model.ApplyQueryOptions(query, *options, &model.ItemCategory{})
		if err != nil {
			return nil, err
		}
	}

	if err := query.Find(&itemCategories).Error; err != nil {
		return nil, err
	}

	return itemCategories, nil
}

// ItemCategory is the resolver for the itemCategory field.
func (r *queryResolver) ItemCategory(ctx context.Context, id string) (*model.ItemCategory, error) {
	entityID, err := uuid.Parse(id)
	if err != nil {
		return nil, err
	}
	var itemCategory model.ItemCategory
	if err := database.DB.First(&itemCategory, "id = ?", entityID).Error; err != nil {
		return nil, err
	}
	return &itemCategory, nil
}

// ID is the resolver for the id field.
func (r *itemCategoryResolver) ID(ctx context.Context, obj *model.ItemCategory) (string, error) {
	return obj.ID.String(), nil
}

// Organization is the resolver for the organization field.
func (r *itemCategoryResolver) Organization(ctx context.Context, obj *model.ItemCategory) (*model.Organization, error) {
	panic(fmt.Errorf("not implemented: Organization - organization"))
}

// ItemCategory returns generated.ItemCategoryResolver implementation.
func (r *Resolver) ItemCategory() generated.ItemCategoryResolver { return &itemCategoryResolver{r} }

type itemCategoryResolver struct{ *Resolver }
